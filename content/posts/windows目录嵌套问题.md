+ dos设备路径：Windows 操作系统有一个指向所有资源（包括文件）的统一对象模型。 可从控制台窗口访问这些对象路径；并通过旧版 DOS 和 UNC 路径映射到的符号链接的特殊文件，将这些对象路径公开至 Win32 层。 
  + 设备路径说明符（`\\.\` 或 `\\?\`），它将路径标识为 DOS 设备路径。
  + 以“\\\?\”开头的设备路径不会进行规范化
  + 为什么要跳过规范化过程？ 主要有三方面的原因：
    1. 为了访问那些通常无法访问但合法的路径。 例如名为 `hidden.` 的文件或目录，这是能访问它的唯一方式。
    2. 为了在已规范化的情况下通过跳过规范化过程来提升性能。
    3. 为了跳过路径长度的 `MAX_PATH` 检查以允许多于 259 个字符的路径（仅在 .NET Framework 上）。 大多数 API 都允许这一点，也有一些例外情况。

> https://docs.microsoft.com/zh-cn/dotnet/standard/io/file-path-formats

+ windows应用当前目录规则：
  + 如果路径非完全限定，Windows 会向其应用当前目录。 不会向 UNC 和设备路径应用当前目录。 带有分隔符的 `C:\` 完整驱动器也不会应用当前目录。
  + 如果路径的开头是单个组件分隔符，则会应用当前目录中的驱动器。 例如，如果文件路径是 `\utilities` 且当前目录为 `C:\temp\`，规范化后路径则为 `C:\utilities`。
  + 如果路径开头是驱动器号和卷分隔符，而没有组件分隔符，则应用从命令行界面为指定驱动器设置的最新当前目录。 如未设置最新当前目录，则只应用驱动器。 例如，如果文件路径为 `D:sources`，当前目录为 `C:\Documents\`，且 D: 盘上的最新当前目录为 `D:\sources\`，则结果为 `D:\sources\sources`。 这些“驱动器相对”路径是导致程序和脚本逻辑错误的常见原因。 假设以字母和冒号开头的路径不是相对路径，显然是不正确的
  + 如果路径不是以分隔符开头的，则应用当前驱动器和当前目录。 例如，如果路径是 `filecompare` 且当前目录是 `C:\utilities\`，则结果为 `C:\utilities\filecompare\`。

+ 完全限定路径以驱动器名称开头 (如果路径位于另一个驱动器上) 并列出从根到文件的显式路径。 未完全限定的任何路径都是相对于当前驱动器和目录的路径。