# Shell学习



## 比较两个字符串是否相等

``` bash
if [ "$test"x = "test"x ]; then
```

+ 注意：
  + 使用单个等号
  + 等号两边有空格
  + **注意到"$test"x最后的x，这是特意安排的，因为当$test为空的时候，上面的表达式就变成了x = testx，显然是不相等的。而如果没有这个x，表达式就会报错：[: =: unary operator expected**
  + 双引号转义"$"，单引号不转义，但是对于"\"转义需要加-e选项

## 将多行写入文件

``` bash
cat >> filename << EOF
```

+ 输入要写入文件的内容，以EOF为结尾，输入结束
+ 在脚本中，最后EOF需要顶格，否则不被识别
+ EOF可以换成其他字符，都是可以当作结束符而不显示在文件中

## echo文字效果

### 文字颜色

``` bash
#字体颜色：30m-37m 黑、红、绿、黄、蓝、紫、青、白
str="kimbo zhang"
echo -e "\033[30m ${str}\033[0m"      ## 黑色字体
echo -e "\033[31m ${str}\033[0m"      ## 红色
echo -e "\033[32m ${str}\033[0m"      ## 绿色
echo -e "\033[33m ${str}\033[0m"      ## 黄色
echo -e "\033[34m ${str}\033[0m"      ## 蓝色
echo -e "\033[35m ${str}\033[0m"      ## 紫色
echo -e "\033[36m ${str}\033[0m"      ## 青色
echo -e "\033[37m ${str}\033[0m"      ## 白色
```

+ echo必须添加-e选项
+ 颜色字符也是成对出现，包含在要添加文字两侧

### 文字背景颜色

``` bash
#背景颜色：40-47 黑、红、绿、黄、蓝、紫、青、白
str="kimbo zhang"
echo -e "\033[41;37m ${str} \033[0m"     ## 红色背景色，白色字体
echo -e "\033[41;33m ${str} \033[0m"     ## 红底黄字
echo -e "\033[1;41;33m ${str} \033[0m"   ## 红底黄字 高亮加粗显示
echo -e "\033[5;41;33m ${str} \033[0m"   ## 红底黄字 字体闪烁显示
echo -e "\033[47;30m ${str} \033[0m"     ## 白底黑字
echo -e "\033[40;37m ${str} \033[0m"     ## 黑底白字
```

### 其他效果

+ \033[1;m 设置高亮加粗
+ \033[4;m 下划线 
+ \033[5;m 闪烁

## shell括号

### 单小括号

+ 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
+ 命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。
+ 用于初始化数组。如：array=(a b c d)

### 双小括号

+ 整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。
+ 只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进制转十进制)。
+ 单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6。
+ 常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in seq 0 4`或者for i in {0..4}。再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。

### 单方括号

+ bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。
+ **Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较**，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \\< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。
+ 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
+ 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

### 双方括号

+ [[是 bash 程序语言的关键字。并不是一个命令，**[[ ]] 结构比[ ]结构更加通用**。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
+ 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
+ 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 
  操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 
  && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
+ bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

### 大括号

+ 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt

+ 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。

+ 几种特殊的替换结构：

  + `${var:-string}和${var:=string}`:若变量var为空，则用在命令行中用string来替换`${var:-string}`，否则变量var不为空时，则用变量var的值来替换`${var:-string}`；对于`${var:=string}`的替换规则和`${var:-string}`是一样的，所不同之处是`${var:=string}`若var为空时，用string替换`${var:=string}`的同时，把string赋给变量var： `${var:=string}`很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。
  + `${var:+string}`的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)
  + `${var:?string}替`换规则为：若变量var不为空，则用变量var的值来替换`${var:?string}`；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
  + **在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。**

+ 四种模式匹配替换结构：

  + 第一种模式：`${variable%pattern}`，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式
  + 第二种模式：` ${variable%%pattern}，`这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
  + 第三种模式：`${variable#pattern}` 这种模式时，shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式
  + 第四种模式： `${variable##pattern} `这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

  > \# 是去掉左边(在键盘上#在$之左边)
  >
  > % 是去掉右边(在键盘上%在$之右边)
  >
  > #和%中的单一符号是最小匹配，两个相同符号是最大匹配。

  + 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。

+ 字符串提取和替换：

  + 第一种模式：`${var:num}`，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var:-2}、${var:1-3}或${var:(-2)}。
  + 第二种模式：`${var:num1:num2}，`num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。
  + 第三种模式：`${var/pattern/pattern}`表示将var字符串的第一个匹配的pattern替换为另一个pattern。
  + 第四种模式：`${var//pattern/pattern}`表示将var字符串中的所有能匹配的pattern替换为另一个pattern。

### 符号$后的括号

+ ${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。
+ $(cmd) 命令替换，和`cmd`效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。
+ $((expression)) 和`exprexpression`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。

## 变量

+ local一般用于局部变量声明，多在函数内部使用
  + shell中定义的变量是全局的，从定义的地方到shell脚本结束或删除的地方为止。
  + 函数定义的变量默认是全局的，作用域从”函数调用时执行变量定义的地方“开始，到shell结束或被删除的地方为止。若函数内变量定义为local，作用域为函数内。函数的参数是local的。
  + 如果同名，函数定义的local变量会屏蔽全局变量。
+ export将自定义的变量设定为系统环境变量（仅限于本次登陆的当前shell中有效）
  + 参数
    + -f 代表变量名称为函数名称
    + -n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
    + -p 列出所有的shell赋予程序的环境变量
+ declare和set类似，可用来声明变量并设置变量的属性（r：只读；x：指定为环境变量；i：值可以是数值，字符串或运算式），也可以用来显示shell函数（-f），不加任何参数，则显示全部shell变量和函数（与执行set效果相同）。

## shell脚本调试

+ 可以在脚本第一行声明解释器后加参数，也可以执行时加参数调试。
+ 参数
  + -n：不执行脚本，只查找脚本语法是否有问题，给出错误提示。
  + -v：执行脚本时，先将脚本的内容输出，然后执行脚本，如果有错误也提示。
  + -x：将执行的脚本内容及输出显示到屏幕上。
  + echo也是很有用的调试工具，配合exit语句中断执行。
+ set命令也可以辅助调试
  + set -n：读取命令不执行
  + set -v：显示读取的所有行
  + set -x：显示所有命令及其参数
  + **提示：通过set -x命令开启调试功能，通过set +x关闭调试功能，可以调试两个命令之间的部分**

## let计算工具

+ let是bash中用于计算的工具，用于执行一个或多个表达式，计算变量不需要加$。如果表达式中出现空格或其他特殊字符，必须引起来

## shell内部域分隔符IFS

+ IFS(Internal Field Seprator)，内部域分隔符
+ IFS是一种 set 变量，当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space，tab，newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。

## 特殊变量

+ $!：后台最近执行命令的PID
+ $?：前台最近命令的结束状态
+ $$：当前shell的PID
+ $#：传递给脚本的参数数目
+ $*：以字符串形式输出所有传递给脚本的参数
+ $@：以$IFS为分隔符列出所有传递到脚本的参数

## xargs与普通管道区别

+ 普通管道会把前一个命令的输出当成后一个命令的输入。

``` bash
echo '--help' | cat
# 输出：
--help
```

+ xargs将其接受的内容当作后一个命令的参数来运行后一个命令。

``` bash
echo '--help' | xargs cat 
# 输出：
Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s), or standard input, to standard output.
 
  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines
  ......
```

+ xargs的其他选项：
  + **-d** 默认情况下xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个之后当作命令行参数传递给其后面的命令，并运行之，我们可以使用 -d 命令指定分隔符。
  + **-p** 使用该选项之后xargs并不会马上执行其后面的命令，而是输出即将要执行的完整的命令(包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。这种方式可以清楚的看到执行的命令是什么样子，也就是xargs传递给命令的参数是什么。
  + **-n** 该选项表示将xargs生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果xargs从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有10个，使用-n 3 之后表示一次传递给xargs后面的命令是3个参数，因为一共有10个参数，所以要执行4次，才能将参数用完。
  + **-E ，有的系统的xargs版本可能是-e  eof-str** 该选项指定一个字符串，当xargs解析出多个命令行参数的时候，如果搜索到-e指定的命令行参数，则只会将-e指定的命令行参数之前的参数(不包括-e指定的这个参数)传递给xargs后面的命令。
  + **注意：-E只有在xargs不指定-d的时候有效，如果指定了-d则不起作用，而不管-d指定的是什么字符，空格也不行。**


